# import the Flask class from the flask module
from flask import Flask, render_template, url_for, request, redirect, session
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, SubmitField, SelectMultipleField
from wtforms.validators import InputRequired, Length, AnyOf
import pandas as pd
import os, subprocess
from data import Data
from projconfig import Projconfig #load project variables and stuff

PC = Projconfig() #initialse local configuarion variables
imageDir = PC.staticDir+PC.imageDir #where images sit
DF_file = PC.staticDir+PC.DF_file #where df sits

DF = pd.read_pickle( DF_file ) #load dataframe
DATA = Data( DF ) #initialise userdata



def _df_getUniqueColItems(df, colStr ):
    '''
    Get the unique elements of the column COLSTR from df.
    Komma-separated items are taken as several items.
    List is alphabetically sorted.
    '''
    if df.empty:
        lis = []
    else:
        s = ','.join(df[colStr].tolist()) #create comma-sepeated string
        LIS = s.split(',') #split at commas, list of all keywords
        lis = list(set(LIS)) #make items unique

    return sorted(lis) #return sorted list

def _boutonfield(name='', label=[], list=[]):
    d = {
        'name' : name,
        'label': label,
        'value': range(0,len(label)),
        'list': list,
        'num' : len(label)
        }
    return d

def _radiofield(df, name=''):
    l = _df_getUniqueColItems(df,name)
    d = {
        'name': name,
        'label': l,
        'value': range(0,len(l)),
        'num'  : len(l)
        }
    return d

class Guidatafix:
    totalnum = len(DF)
    sortMode = _boutonfield(name='sortMode', label=['sorted','shuffle'])
    displayMode = _boutonfield(name='displayMode', label=['Grid','Stapel'])
    imSize = _boutonfield(name='imSize', label=['k','K','g', 'G'], list=['200px','400px','600px','800px'])
    kurzel = _radiofield(DF, name='kurzel')
    topic = _radiofield(DF, name='topic')
    basal = _radiofield(DF, name='basal')
    diff = _radiofield(DF, name='diff')
    qpics_fn = DF['qImage_path'].to_list()
    apics_fn = DF['aImage_path'].to_list()

def guidatauser_init(gdfix):
    ud = {
        'dropdownmenu_down': False,
        'fromwhom': '',
        'sortMode': {
            'isSel': [True, False]
            },
        'displayMode': {
            'isSel': [True, False]
            },
        'imSize': {
            'isSel': [False, False, True, False]
            },
        'kurzel': {
            'isSel': [0 for item in gdfix.kurzel['label']],
            'numSel' : 0
            },
        'topic': {
            'isSel': [0 for item in gdfix.topic['label']],
            'numSel' : 0
            },
        'basal': {
            'isSel': [0 for item in gdfix.basal['label']],
            'numSel' : 0
            },
        'diff': {
            'isSel': [0 for item in gdfix.diff['label']],
            'numSel' : 0
            }
    }
    return ud

def guidatauser_update(gduser, data):
    '''
    Determines the logic of the gui.
    As all input elements are buttons, the data elements
    consist of a dict of the simple form {name, value}.
    '''
    for key, value in data.items():
        name = key #e.g. 'imSize'
        val = value #e.g. '0'

    if name in ['sortMode','displayMode','imSize']:
        #only one button is allowed to be active
        gduser['dropdownmenu_down'] = False
        gduser[name]['isSel'] = [False for i in gduser[name]['isSel']]
        gduser[name]['isSel'][int(val)] = True

    elif name in ['kurzel', 'topic', 'basal', 'diff']:
        #update pressed button: 0=neutral, 1=include, 2=exclude
        gduser['dropdownmenu_down'] = True
        gduser[name]['isSel'][int(val)] = gduser[name]['isSel'][int(val)] + 1
        if gduser[name]['isSel'][int(val)] > 2:
            gduser[name]['isSel'][int(val)] = 0

    gduser['fromwhom'] = name

    return gduser

def _df_filterByCol(df, colStr, whatStrList ):
    '''
        Gets a new df with only rows containing the strings in WHATSTRLIST in COLSTR.
        Empty whatStrList does nothing to df.
        Empty df does nothing.
    '''
    if len(whatStrList)>0 and ~df.empty:
        df = df[df[colStr].str.contains('|'.join(whatStrList))]

    return df

def filterDataframe(gdf, gdu):
    '''
    Create new dataframe from DF based on gdfix gdf and gduser gdu.
    '''

    R = gdu['kurzel']['isSel'] #could be 0 (ignore),1 (include), or 2 (exclude)
    wsl_incl = [ gdf.kurzel['label'][i] for i in range(0,len(R)) if R[i] == 1 ]
    wsl_exc  = [ gdf.kurzel['label'][i] for i in range(0,len(R)) if R[i] != 2  ]





gdfix = Guidatafix()
# gduser = guidatauser_init(gdfix)
# print(gduser['imSize']['isSel'])
# gduser = guidatauser_update(gduser, {'imSize':'1'})
# print(gduser['imSize']['isSel'])




# create the application object
app = Flask(__name__)
app.config["SECRET_KEY"] = "bigsecret!"
app.config["DEBUG"] = True













def df_sortByCol( df, colStr ):
    "sort df by column COLSTR"
    df = df.sort_values(by=colStr, ascending=True)
    return df



class LoginForm(FlaskForm):
    username = StringField('Username', validators=[InputRequired(), Length(min=2, max=10, message='Must be between 2 and 10 characters')])
    password = PasswordField('Password', validators=[InputRequired(), AnyOf(values=['bam', 'gym'])])
    language = SelectMultipleField(u'Programming Language', choices=[('cpp', 'C++'), ('py', 'Python'), ('text', 'Plain Text')])



# use decorators to link the function to a url
@app.route('/')
def index():
    # return redirect(url_for('lul'))
    return redirect(url_for('login'))

@app.route('/login', methods=['POST', 'GET'])
def login():
    form = LoginForm()

    if form.validate_on_submit():
        return 'username: {}, password: {}, language: {}'.format(form.username.data, form.password.data, form.language.data)

    return render_template('login.html', form=form)




@app.route('/lul', methods=['POST', 'GET'])
def lul():

    if 'gduser' not in session or request.method == 'GET':
        session['gduser'] = guidatauser_init(gdfix)

    gduser = session['gduser']
    userdata=DATA
    #userdata = session["userdata"]

    answ=''


    #just for testing
    if request.method == 'POST':
        #I am only here because soemthing was triggered!

        # #buttons, so if triggered, will be not empty
        # r1 = request.form.getlist('imSize')
        # r2 = request.form.getlist('displayMode')
        #
        answ = request.form.to_dict()
        gduser = guidatauser_update(gduser, answ)
        session['gduser']=gduser
        #
        # if len(r1)>1:
        #     userdata.update_isSel( r1 )
        #     userdata.update_filterList()
        #     userdata.SHOWFLAG = False
        #
        # elif len(r2)>1:
        #     userdata.update_isSel( r2 )
        #     userdata.update_filterList()
        #     userdata.SHOWFLAG = False
        #
        # else:
        #     #I am here because one of the checkmarks in a group was triggered (kurzel, ...).
        #     #All groups that did not trigger the response return empty [].
        #     #The group that triggered the response returns ['kurzel','WiD',...].
        #     #In the case where the only mark in a group gets uncheck: ['kurzel']
        #
        #     #update selections
        #     kur = request.form.getlist('kurzel')
        #     userdata.update_isSel( kur )
        #     top = request.form.getlist('topic')
        #     userdata.update_isSel( top )
        #     bas = request.form.getlist('basal')
        #     userdata.update_isSel( bas )
        #     dif = request.form.getlist('diff')
        #     userdata.update_isSel( dif )
        #
        #     #filter df
        #     userdata.update_filterList()
        #     df = df_filterByCol( DF, 'kurzel', userdata.kurzel['filterList'] )
        #     df = df_filterByCol( df, 'topic', userdata.topic['filterList'] )
        #     df = df_filterByCol( df, 'basal', userdata.basal['filterList'] )
        #     df = df_filterByCol( df, 'diff', userdata.diff['filterList'] )
        #
        #     userdata.SHOWFLAG = True #make sure input menue stays down
        #
        #     #check if I need to shuffle
        #     r3 = request.form.getlist('sortMode')
        #     if len(r3)>1: #yep
        #         userdata.update_isSel( r3 )
        #         df = df.sample(frac=1) #shuffle rows
        #         userdata.SHOWFLAG = False
        #
        #     #update num and pics based on df
        #     userdata.update_num(df)
        #     userdata.update_pics(df)

        #session["test"]="test2"

    return render_template('lul.html', DATA=userdata, GDFIX=gdfix, GDUSER=gduser,  answ=answ)

#clears cache in browser
# @app.after_request
# def add_header(response):
#     response.cache_control.max_age = 0
#     return response

# start the server with the 'run()' method
if __name__ == '__main__':
    app.run()
